#ifndef avl
#define avl



#include <iostream>
#include <vector>
#include <algorithm>

#include "nodo.h"

using namespace std;

class BinaryTree {
private:
    nodo* root;

    int altura(nodo* nodo) {
        if (nodo == nullptr) {
            return 0;
        }
        return nodo->altura;
    }

    int max(int a, int b) {
        return (a > b) ? a : b;
    }

    nodo* rotateRight(nodo* y) {
        nodo* x = y->left;
        nodo* T2 = x->right;

        x->right = y;
        y->left = T2;

        y->altura = max(altura(y->left), altura(y->right)) + 1;
        x->altura = max(altura(x->left), altura(x->right)) + 1;

        return x;
    }

    nodo* rotateLeft(nodo* x) {
        nodo* y = x->right;
        nodo* T2 = y->left;

        y->left = x;
        x->right = T2;

        x->altura = max(altura(x->left), altura(x->right) + 1);
        y->altura = max(altura(y->left), altura(y->right) + 1);

        return y;
    }

    int getBalance(nodo* nodo) {
        if (nodo == nullptr) {
            return 0;
        }
        return altura(nodo->left) - altura(nodo->right);
    }

    nodo* insert(nodo* nodo, const string& titulo, const vector<string>& temas) {
        if (nodo == nullptr) {
            return new struct nodo(titulo, temas);
        }

        if (titulo < nodo->bookTitle) {
            nodo->left = insert(nodo->left, titulo, temas);
        } else if (titulo > nodo->bookTitle) {
            nodo->right = insert(nodo->right, titulo, temas);
        }

        nodo->altura = 1 + max(altura(nodo->left), altura(nodo->right));

        int balance = getBalance(nodo);

        if (balance > 1 && titulo < nodo->left->bookTitle) {
            return rotateRight(nodo);
        }
        if (balance < -1 && titulo > nodo->right->bookTitle) {
            return rotateLeft(nodo);
        }
        if (balance > 1 && titulo > nodo->left->bookTitle) {
            nodo->left = rotateLeft(nodo->left);
            return rotateRight(nodo);
        }
        if (balance < -1 && titulo < nodo->right->bookTitle) {
            nodo->right = rotateRight(nodo->right);
            return rotateLeft(nodo);
        }

        return nodo;
    }

    void inOrderTraversal(nodo* nodo) {
        if (nodo != nullptr) {
            inOrderTraversal(nodo->left);
            cout << "Titulo: " << nodo->bookTitle << "\n";
            for (const string& tema : nodo->bookThemes) {
                cout << "Tema: " << tema << "\n";
            }
            inOrderTraversal(nodo->right);
        }
    }

    nodo* buscar(nodo* nodo, const string& titulo) {
        if (nodo == nullptr || nodo->bookTitle == titulo) {
            return nodo;
        }
        if (titulo < nodo->bookTitle) {
            return buscar(nodo->left, titulo);
        } else {
            return buscar(nodo->right, titulo);
        }
    }

public:
    BinaryTree() : root(nullptr) {}

    void insert(const string& titulo, const vector<string>& temas) {
        root = insert(root, titulo, temas);
    }

    void traverseInOrder() {
        inOrderTraversal(root);
    }

    nodo* search(const string& titulo) {
        return buscar(root, titulo);
    }
};
#endifs